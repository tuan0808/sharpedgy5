/*
 The MIT License (MIT)

 Copyright (C) 2017-2023 Stefano Cappa (Ks89)

 Permission is hereby granted, free of charge, to any person obtaining a copy
 of this software and associated documentation files (the "Software"), to deal
 in the Software without restriction, including without limitation the rights
 to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 copies of the Software, and to permit persons to whom the Software is
 furnished to do so, subject to the following conditions:

 The above copyright notice and this permission notice shall be included in all
 copies or substantial portions of the Software.

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE AND NON INFRINGEMENT. IN NO EVENT SHALL THE
 AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 SOFTWARE.
 */
import { ChangeDetectionStrategy, Component, EventEmitter, Input, Output } from '@angular/core';
import { GridLayout, LineLayout, PlainGalleryStrategy } from '../../model/plain-gallery-config.interface';
import { getIndex } from '../../utils/image.util';
import { NEXT } from '../../utils/user-input.util';
import { AccessibleComponent } from '../accessible.component';
import * as i0 from "@angular/core";
import * as i1 from "../../services/config.service";
import * as i2 from "@angular/common";
import * as i3 from "../../directives/size.directive";
import * as i4 from "../../directives/wrap.directive";
import * as i5 from "../../directives/direction.directive";
import * as i6 from "../../directives/a-tag-bg-image.directive";
import * as i7 from "../../directives/fallback-image.directive";
/**
 * Component with the gallery of thumbs.
 * In receives an array of Images, a boolean to show/hide
 * the gallery (feature used by imagePointer) and a config
 * object to customize the behaviour of this component.
 * Also, it emits click events as outputs.
 */
export class PlainGalleryComponent extends AccessibleComponent {
    constructor(configService) {
        super();
        this.configService = configService;
        /**
         * Array of `Image` that represent the model of this library with all images, thumbs and so on.
         */
        this.images = [];
        /**
         * Output to emit an event when an image is clicked.
         */
        this.clickImage = new EventEmitter();
        /**
         * Bi-dimensional array of `Image` object to store images to display as plain gallery.
         * [] by default.
         */
        this.imageGrid = [];
        /**
         * Boolean passed as input to `ks-wrap` directive to configure flex-wrap css property.
         * However it's not enough, because you need to limit the width using `widthStyle` public variable.
         * For more info check https://developer.mozilla.org/it/docs/Web/CSS/flex-wrap
         */
        this.wrapStyle = false;
        /**
         * String passed as input to `ks-wrap` directive to set width to be able to force overflow.
         * In this way, `wrapStyle` (flex-wrap css property) will be used as requested.
         */
        this.widthStyle = '';
    }
    /**
     * Method Â´ngOnInitÂ´ to init both `configPlainGallery` calling `initPlainGalleryConfig()`
     * and `imageGrid invoking `initImageGrid()`.
     * This is an angular lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called only one time!!!
     */
    ngOnInit() {
        if (this.id === null || this.id === undefined) {
            throw new Error('Internal library error - id must be defined');
        }
        this.configService.setConfig(this.id, this.config);
        const libConfig = this.configService.getConfig(this.id);
        if (!libConfig) {
            throw new Error('Internal library error - libConfig must be defined');
        }
        this.accessibilityConfig = libConfig.accessibilityConfig;
        this.plainGalleryConfig = libConfig.plainGalleryConfig;
        this.initImageGrid();
    }
    /**
     * Method Â´ngOnChangesÂ´ to update both `imageGrid` and`plainGalleryConfig`.
     * This is an angular lifecycle hook, so its called automatically by Angular itself.
     * In particular, it's called when any data-bound property of a directive changes!!!
     */
    ngOnChanges(changes) {
        if (this.id === null || this.id === undefined) {
            throw new Error('Internal library error - id must be defined');
        }
        const libConfig = this.configService.getConfig(this.id);
        if (!libConfig) {
            throw new Error('Internal library error - libConfig must be defined');
        }
        const imagesChange = changes.images;
        const configChange = changes.config;
        // I'm using !change.firstChange because the first time will be called both onInit and onChange and I don't
        // want to execute initialization two times.
        if (configChange &&
            !configChange.firstChange &&
            (configChange.previousValue !== configChange.currentValue || (!configChange.previousValue && !configChange.currentValue))) {
            this.plainGalleryConfig = libConfig.plainGalleryConfig;
            // this.configPlainGallery = this.initPlainGalleryConfig();
        }
        if (imagesChange && !imagesChange.firstChange && imagesChange.previousValue !== imagesChange.currentValue) {
            this.initImageGrid();
        }
    }
    /**
     * Method called when you click on an image of the plain (or inline) gallery.
     * This will emit the show event with the image as payload.
     * @param Image img is the Image to show
     */
    showModalGalleryByImage(img) {
        const index = this.images.findIndex((val) => val && img && val.id === img.id);
        this.showModalGallery(index);
    }
    /**
     * Method called when you navigate between images.
     * This will emit the show event with the image as payload.
     * @param KeyboardEvent event that triggered the navigation
     * @param Image img is the Image to show
     */
    onNavigationEvent(event, img) {
        const result = super.handleImageEvent(event);
        if (result === NEXT) {
            this.showModalGalleryByImage(img);
        }
    }
    /**
     * Method to get `alt attribute`.
     * `alt` specifies an alternate text for an image, if the image cannot be displayed.
     * @param Image image to get its alt description.
     * @returns string alt description of the image
     */
    getAltPlainDescriptionByImage(image) {
        if (!image) {
            return '';
        }
        return image.plain && image.plain.description ? image.plain.description : `Image ${getIndex(image, this.images) + 1}`;
    }
    /**
     * Method to get the title for an image.
     * @param Image image to get its title
     * @returns string the title of the input image
     */
    getTitleDisplay(image) {
        let description = '';
        if (image.plain && image.plain.description) {
            description = image.plain.description;
        }
        else if (image.modal && image.modal.description) {
            description = image.modal.description;
        }
        const currentIndex = getIndex(image, this.images);
        const prevDescription = 'Image ' + (currentIndex + 1) + '/' + this.images.length;
        let currImgDescription = description ? description : '';
        if (currImgDescription !== '') {
            currImgDescription = ' - ' + currImgDescription;
        }
        return prevDescription + currImgDescription;
    }
    /**
     * Method used in the template to track ids in ngFor.
     * @param number index of the array
     * @param Image item of the array
     * @returns number the id of the item
     */
    trackById(index, item) {
        return item.id;
    }
    /**
     * Method called when you click on an image of the plain (or inline) gallery.
     * This will emit the show event with the index number as payload.
     * @param number index of the clicked image
     */
    showModalGallery(index) {
        this.clickImage.emit(index);
    }
    /**
     * Private method to init both `imageGrid` and other style variables,
     * based on the layout type.
     */
    initImageGrid() {
        if (!this.plainGalleryConfig) {
            throw new Error('Internal library error - plainGalleryConfig must be defined');
        }
        // reset the array to prevent issues in case of GridLayout
        this.imageGrid = [];
        if (this.plainGalleryConfig.layout instanceof LineLayout) {
            const layout = this.plainGalleryConfig.layout;
            const row = this.images.filter((val, i) => i < layout.breakConfig.length || layout.breakConfig.length === -1);
            this.imageGrid = [row];
            this.size = this.plainGalleryConfig.layout.size;
            switch (this.plainGalleryConfig.strategy) {
                case PlainGalleryStrategy.ROW:
                    this.directionStyle = 'row';
                    break;
                case PlainGalleryStrategy.COLUMN:
                    this.directionStyle = 'column';
                    this.wrapStyle = layout.breakConfig.wrap;
                    break;
            }
            this.justifyStyle = layout.justify;
        }
        if (this.plainGalleryConfig.layout instanceof GridLayout) {
            const layout = this.plainGalleryConfig.layout;
            const count = Math.ceil(this.images.length / layout.breakConfig.length);
            let start = 0;
            let end = layout.breakConfig.length - 1;
            for (let j = 0; j < count; j++) {
                const row = this.images.filter((val, i) => i >= start && i <= end);
                this.imageGrid.push(row);
                start = end + 1;
                end = start + layout.breakConfig.length - 1;
            }
            this.size = this.plainGalleryConfig.layout.size;
            const pixels = +layout.size.width.replace('px', '');
            this.widthStyle = pixels * layout.breakConfig.length + pixels / 2 + 'px';
            this.wrapStyle = layout.breakConfig.wrap;
            this.directionStyle = 'row';
        }
    }
    static { this.Éµfac = i0.ÉµÉµngDeclareFactory({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: PlainGalleryComponent, deps: [{ token: i1.ConfigService }], target: i0.ÉµÉµFactoryTarget.Component }); }
    static { this.Éµcmp = i0.ÉµÉµngDeclareComponent({ minVersion: "14.0.0", version: "17.0.5", type: PlainGalleryComponent, selector: "ks-plain-gallery", inputs: { id: "id", images: "images", config: "config" }, outputs: { clickImage: "clickImage" }, usesInheritance: true, usesOnChanges: true, ngImport: i0, template: "<div class=\"plain-container\"\n     ksWrap [wrap]=\"wrapStyle\" [width]=\"widthStyle\"\n     ksDirection [direction]=\"directionStyle\" [justify]=\"justifyStyle\"\n     [attr.aria-label]=\"accessibilityConfig?.plainGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig?.plainGalleryContentTitle\">\n\n  <ng-container *ngFor=\"let imgRow of imageGrid; let i = index\">\n    <ng-container *ngFor=\"let imgCol of imgRow; let j = index\">\n\n      <ng-container *ngIf=\"!plainGalleryConfig?.advanced?.aTags; else aTags\">\n        <img *ngIf=\"imgCol?.modal?.img\"\n             [loading]=\"imgCol.loading\"\n             [attr.fetchpriority]=\"imgCol.fetchpriority\"\n             [src]=\"imgCol.plain?.img! ? imgCol.plain?.img! : imgCol.modal.img\"\n             ksFallbackImage [fallbackImg]=\"imgCol.plain?.fallbackImg ? imgCol.plain?.fallbackImg : imgCol.modal.fallbackImg\"\n             class=\"image\"\n             ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n             [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n             [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n             alt=\"{{imgCol.plain?.alt! ? imgCol.plain?.alt! : getAltPlainDescriptionByImage(imgCol)}}\"\n             [tabIndex]=\"0\" role=\"img\"\n             (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"/>\n      </ng-container>\n\n      <!-- Add directive to set background with the image url as param to pass thumb or img-->\n      <!-- to do something like this <a style=\"background: url('path to image') 50% 50%/cover\">.-->\n      <ng-template #aTags>\n        <a *ngIf=\"imgCol?.modal?.img\"\n           class=\"a-tag-image\"\n           ksATagBgImage [image]=\"imgCol\" [style]=\"plainGalleryConfig?.advanced?.additionalBackground\"\n           ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n           [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n           [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n           [tabIndex]=\"0\"\n           (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"></a>\n      </ng-template>\n\n    </ng-container>\n  </ng-container>\n\n</div>\n\n", styles: [".plain-container{align-items:center;display:flex}.plain-container .image{cursor:pointer;height:auto;margin:2px;width:50px}.plain-container .a-tag-image{cursor:pointer;margin:2px}\n"], dependencies: [{ kind: "directive", type: i2.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i2.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i3.SizeDirective, selector: "[ksSize]", inputs: ["sizeConfig"] }, { kind: "directive", type: i4.WrapDirective, selector: "[ksWrap]", inputs: ["wrap", "width"] }, { kind: "directive", type: i5.DirectionDirective, selector: "[ksDirection]", inputs: ["direction", "justify"] }, { kind: "directive", type: i6.ATagBgImageDirective, selector: "[ksATagBgImage]", inputs: ["image", "style"] }, { kind: "directive", type: i7.FallbackImageDirective, selector: "[ksFallbackImage]", inputs: ["fallbackImg"], outputs: ["fallbackApplied"] }], changeDetection: i0.ChangeDetectionStrategy.OnPush }); }
}
i0.ÉµÉµngDeclareClassMetadata({ minVersion: "12.0.0", version: "17.0.5", ngImport: i0, type: PlainGalleryComponent, decorators: [{
            type: Component,
            args: [{ selector: 'ks-plain-gallery', changeDetection: ChangeDetectionStrategy.OnPush, template: "<div class=\"plain-container\"\n     ksWrap [wrap]=\"wrapStyle\" [width]=\"widthStyle\"\n     ksDirection [direction]=\"directionStyle\" [justify]=\"justifyStyle\"\n     [attr.aria-label]=\"accessibilityConfig?.plainGalleryContentAriaLabel\"\n     [title]=\"accessibilityConfig?.plainGalleryContentTitle\">\n\n  <ng-container *ngFor=\"let imgRow of imageGrid; let i = index\">\n    <ng-container *ngFor=\"let imgCol of imgRow; let j = index\">\n\n      <ng-container *ngIf=\"!plainGalleryConfig?.advanced?.aTags; else aTags\">\n        <img *ngIf=\"imgCol?.modal?.img\"\n             [loading]=\"imgCol.loading\"\n             [attr.fetchpriority]=\"imgCol.fetchpriority\"\n             [src]=\"imgCol.plain?.img! ? imgCol.plain?.img! : imgCol.modal.img\"\n             ksFallbackImage [fallbackImg]=\"imgCol.plain?.fallbackImg ? imgCol.plain?.fallbackImg : imgCol.modal.fallbackImg\"\n             class=\"image\"\n             ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n             [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n             [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n             alt=\"{{imgCol.plain?.alt! ? imgCol.plain?.alt! : getAltPlainDescriptionByImage(imgCol)}}\"\n             [tabIndex]=\"0\" role=\"img\"\n             (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"/>\n      </ng-container>\n\n      <!-- Add directive to set background with the image url as param to pass thumb or img-->\n      <!-- to do something like this <a style=\"background: url('path to image') 50% 50%/cover\">.-->\n      <ng-template #aTags>\n        <a *ngIf=\"imgCol?.modal?.img\"\n           class=\"a-tag-image\"\n           ksATagBgImage [image]=\"imgCol\" [style]=\"plainGalleryConfig?.advanced?.additionalBackground\"\n           ksSize [sizeConfig]=\"{width: size?.width!, height: size?.height!}\"\n           [attr.aria-label]=\"imgCol.plain?.ariaLabel\"\n           [title]=\"(imgCol.plain?.title || imgCol.plain?.title === '') ? imgCol.plain?.title : getTitleDisplay(imgCol)\"\n           [tabIndex]=\"0\"\n           (click)=\"showModalGalleryByImage(imgCol)\" (keyup)=\"onNavigationEvent($event, imgCol)\"></a>\n      </ng-template>\n\n    </ng-container>\n  </ng-container>\n\n</div>\n\n", styles: [".plain-container{align-items:center;display:flex}.plain-container .image{cursor:pointer;height:auto;margin:2px;width:50px}.plain-container .a-tag-image{cursor:pointer;margin:2px}\n"] }]
        }], ctorParameters: () => [{ type: i1.ConfigService }], propDecorators: { id: [{
                type: Input
            }], images: [{
                type: Input
            }], config: [{
                type: Input
            }], clickImage: [{
                type: Output
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGxhaW4tZ2FsbGVyeS5jb21wb25lbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9rczg5L2FuZ3VsYXItbW9kYWwtZ2FsbGVyeS9zcmMvbGliL2NvbXBvbmVudHMvcGxhaW4tZ2FsbGVyeS9wbGFpbi1nYWxsZXJ5LmNvbXBvbmVudC50cyIsIi4uLy4uLy4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2tzODkvYW5ndWxhci1tb2RhbC1nYWxsZXJ5L3NyYy9saWIvY29tcG9uZW50cy9wbGFpbi1nYWxsZXJ5L3BsYWluLWdhbGxlcnkuaHRtbCJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztHQXNCRztBQUVILE9BQU8sRUFBRSx1QkFBdUIsRUFBRSxTQUFTLEVBQUUsWUFBWSxFQUFFLEtBQUssRUFBcUIsTUFBTSxFQUErQixNQUFNLGVBQWUsQ0FBQztBQUtoSixPQUFPLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBc0Isb0JBQW9CLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUU5SCxPQUFPLEVBQUUsUUFBUSxFQUFFLE1BQU0sd0JBQXdCLENBQUM7QUFFbEQsT0FBTyxFQUFFLElBQUksRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQ25ELE9BQU8sRUFBRSxtQkFBbUIsRUFBRSxNQUFNLHlCQUF5QixDQUFDOzs7Ozs7Ozs7QUFHOUQ7Ozs7OztHQU1HO0FBT0gsTUFBTSxPQUFPLHFCQUFzQixTQUFRLG1CQUFtQjtJQW1FNUQsWUFBb0IsYUFBNEI7UUFDOUMsS0FBSyxFQUFFLENBQUM7UUFEVSxrQkFBYSxHQUFiLGFBQWEsQ0FBZTtRQTNEaEQ7O1dBRUc7UUFFSCxXQUFNLEdBQVksRUFBRSxDQUFDO1FBT3JCOztXQUVHO1FBRUgsZUFBVSxHQUF5QixJQUFJLFlBQVksRUFBVSxDQUFDO1FBYTlEOzs7V0FHRztRQUNILGNBQVMsR0FBYyxFQUFFLENBQUM7UUFLMUI7Ozs7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TUFBTSxNQUFNLEdBQVcsQ0FBQyxNQUFNLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxPQUFPLENBQUMsSUFBSSxFQUFFLEVBQUUsQ0FBQyxDQUFDO1lBRTVELElBQUksQ0FBQyxVQUFVLEdBQUcsTUFBTSxHQUFHLE1BQU0sQ0FBQyxXQUFXLENBQUMsTUFBTSxHQUFHLE1BQU0sR0FBRyxDQUFDLEdBQUcsSUFBSSxDQUFDO1lBQ3pFLElBQUksQ0FBQyxTQUFTLEdBQUcsTUFBTSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUM7WUFFekMsSUFBSSxDQUFDLGNBQWMsR0FBRyxLQUFLLENBQUM7U0FDN0I7SUFDSCxDQUFDOzhHQS9QVSxxQkFBcUI7a0dBQXJCLHFCQUFxQixxTUNsRGxDLGl6RUEwQ0E7OzJGRFFhLHFCQUFxQjtrQkFOakMsU0FBUzsrQkFDRSxrQkFBa0IsbUJBR1gsdUJBQXVCLENBQUMsTUFBTTtrRkFRL0MsRUFBRTtzQkFERCxLQUFLO2dCQU9OLE1BQU07c0JBREwsS0FBSztnQkFNTixNQUFNO3NCQURMLEtBQUs7Z0JBT04sVUFBVTtzQkFEVCxNQUFNIiwic291cmNlc0NvbnRlbnQiOlsiLypcbiBUaGUgTUlUIExpY2Vuc2UgKE1JVClcblxuIENvcHlyaWdodCAoQykgMjAxNy0yMDIzIFN0ZWZhbm8gQ2FwcGEgKEtzODkpXG5cbiBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYSBjb3B5XG4gb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmcgd2l0aG91dCBsaW1pdGF0aW9uIHRoZSByaWdodHNcbiB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsXG4gY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZSBmb2xsb3dpbmcgY29uZGl0aW9uczpcblxuIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuIGNvcGllcyBvciBzdWJzdGFudGlhbCBwb3J0aW9ucyBvZiB0aGUgU29mdHdhcmUuXG5cbiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gSU1QTElFRCwgSU5DTFVESU5HIEJVVCBOT1QgTElNSVRFRCBUTyBUSEUgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFksXG4gRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTiBJTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuIEFVVEhPUlMgT1IgQ09QWVJJR0hUIEhPTERFUlMgQkUgTElBQkxFIEZPUiBBTlkgQ0xBSU0sIERBTUFHRVMgT1IgT1RIRVJcbiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SIE9USEVSV0lTRSwgQVJJU0lORyBGUk9NLFxuIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gU09GVFdBUkUuXG4gKi9cblxuaW1wb3J0IHsgQ2hhbmdlRGV0ZWN0aW9uU3RyYXRlZ3ksIENvbXBvbmVudCwgRXZlbnRFbWl0dGVyLCBJbnB1dCwgT25DaGFuZ2VzLCBPbkluaXQsIE91dHB1dCwgU2ltcGxlQ2hhbmdlLCBTaW1wbGVDaGFuZ2VzIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IEFjY2Vzc2liaWxpdHlDb25maWcgfSBmcm9tICcuLi8uLi9tb2RlbC9hY2Nlc3NpYmlsaXR5LmludGVyZmFjZSc7XG5pbXBvcnQgeyBJbWFnZSB9IGZyb20gJy4uLy4uL21vZGVsL2ltYWdlLmNsYXNzJztcbmltcG9ydCB7IFNpemUgfSBmcm9tICcuLi8uLi9tb2RlbC9zaXplLmludGVyZmFjZSc7XG5pbXBvcnQgeyBHcmlkTGF5b3V0LCBMaW5lTGF5b3V0LCBQbGFpbkdhbGxlcnlDb25maWcsIFBsYWluR2FsbGVyeVN0cmF0ZWd5IH0gZnJvbSAnLi4vLi4vbW9kZWwvcGxhaW4tZ2FsbGVyeS1jb25maWcuaW50ZXJmYWNlJztcblxuaW1wb3J0IHsgZ2V0SW5kZXggfSBmcm9tICcuLi8uLi91dGlscy9pbWFnZS51dGlsJztcbmltcG9ydCB7IENvbmZpZ1NlcnZpY2UgfSBmcm9tICcuLi8uLi9zZXJ2aWNlcy9jb25maWcuc2VydmljZSc7XG5pbXBvcnQgeyBORVhUIH0gZnJvbSAnLi4vLi4vdXRpbHMvdXNlci1pbnB1dC51dGlsJztcbmltcG9ydCB7IEFjY2Vzc2libGVDb21wb25lbnQgfSBmcm9tICcuLi9hY2Nlc3NpYmxlLmNvbXBvbmVudCc7XG5pbXBvcnQgeyBQbGFpbkxpYkNvbmZpZywgTGliQ29uZmlnIH0gZnJvbSAnLi4vLi4vbW9kZWwvbGliLWNvbmZpZy5pbnRlcmZhY2UnO1xuXG4vKipcbiAqIENvbXBvbmVudCB3aXRoIHRoZSBnYWxsZXJ5IG9mIHRodW1icy5cbiAqIEluIHJlY2VpdmVzIGFuIGFycmF5IG9mIEltYWdlcywgYSBib29sZWFuIHRvIHNob3cvaGlkZVxuICogdGhlIGdhbGxlcnkgKGZlYXR1cmUgdXNlZCBieSBpbWFnZVBvaW50ZXIpIGFuZCBhIGNvbmZpZ1xuICogb2JqZWN0IHRvIGN1c3RvbWl6ZSB0aGUgYmVoYXZpb3VyIG9mIHRoaXMgY29tcG9uZW50LlxuICogQWxzbywgaXQgZW1pdHMgY2xpY2sgZXZlbnRzIGFzIG91dHB1dHMuXG4gKi9cbkBDb21wb25lbnQoe1xuICBzZWxlY3RvcjogJ2tzLXBsYWluLWdhbGxlcnknLFxuICBzdHlsZVVybHM6IFsncGxhaW4tZ2FsbGVyeS5zY3NzJ10sXG4gIHRlbXBsYXRlVXJsOiAncGxhaW4tZ2FsbGVyeS5odG1sJyxcbiAgY2hhbmdlRGV0ZWN0aW9uOiBDaGFuZ2VEZXRlY3Rpb25TdHJhdGVneS5PblB1c2hcbn0pXG5leHBvcnQgY2xhc3MgUGxhaW5HYWxsZXJ5Q29tcG9uZW50IGV4dGVuZHMgQWNjZXNzaWJsZUNvbXBvbmVudCBpbXBsZW1lbnRzIE9uSW5pdCwgT25DaGFuZ2VzIHtcbiAgLyoqXG4gICAqIFVuaXF1ZSBpZCAoPj0wKSBvZiB0aGUgY3VycmVudCBpbnN0YW5jZSBvZiB0aGlzIGxpYnJhcnkuIFRoaXMgaXMgcmVxdWlyZWQgd2hlbiB5b3UgYXJlIHVzaW5nXG4gICAqIHRoZSBzZXJ2aWNlIHRvIGNhbGwgbW9kYWwgZ2FsbGVyeS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGlkOiBudW1iZXIgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEFycmF5IG9mIGBJbWFnZWAgdGhhdCByZXByZXNlbnQgdGhlIG1vZGVsIG9mIHRoaXMgbGlicmFyeSB3aXRoIGFsbCBpbWFnZXMsIHRodW1icyBhbmQgc28gb24uXG4gICAqL1xuICBASW5wdXQoKVxuICBpbWFnZXM6IEltYWdlW10gPSBbXTtcbiAgLyoqXG4gICAqIFBsYWluTGliQ29uZmlnIG9iamVjdCB0byBjb25maWd1cmUgcGxhaW4tZ2FsbGVyeS5cbiAgICovXG4gIEBJbnB1dCgpXG4gIGNvbmZpZzogUGxhaW5MaWJDb25maWcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIE91dHB1dCB0byBlbWl0IGFuIGV2ZW50IHdoZW4gYW4gaW1hZ2UgaXMgY2xpY2tlZC5cbiAgICovXG4gIEBPdXRwdXQoKVxuICBjbGlja0ltYWdlOiBFdmVudEVtaXR0ZXI8bnVtYmVyPiA9IG5ldyBFdmVudEVtaXR0ZXI8bnVtYmVyPigpO1xuXG4gIC8qKlxuICAgKiBPYmplY3Qgb2YgdHlwZSBgUGxhaW5HYWxsZXJ5Q29uZmlnYCB0byBjb25maWd1cmUgdGhlIHBsYWluIGdhbGxlcnkuXG4gICAqL1xuICBwbGFpbkdhbGxlcnlDb25maWc6IFBsYWluR2FsbGVyeUNvbmZpZyB8IHVuZGVmaW5lZDtcblxuICAvKipcbiAgICogT2JqZWN0IG9mIHR5cGUgYEFjY2Vzc2liaWxpdHlDb25maWdgIHRvIGluaXQgY3VzdG9tIGFjY2Vzc2liaWxpdHkgZmVhdHVyZXMuXG4gICAqIEZvciBpbnN0YW5jZSwgaXQgY29udGFpbnMgdGl0bGVzLCBhbHQgdGV4dHMsIGFyaWEtbGFiZWxzIGFuZCBzbyBvbi5cbiAgICovXG4gIGFjY2Vzc2liaWxpdHlDb25maWc6IEFjY2Vzc2liaWxpdHlDb25maWcgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIEJpLWRpbWVuc2lvbmFsIGFycmF5IG9mIGBJbWFnZWAgb2JqZWN0IHRvIHN0b3JlIGltYWdlcyB0byBkaXNwbGF5IGFzIHBsYWluIGdhbGxlcnkuXG4gICAqIFtdIGJ5IGRlZmF1bHQuXG4gICAqL1xuICBpbWFnZUdyaWQ6IEltYWdlW11bXSA9IFtdO1xuICAvKipcbiAgICogU2l6ZSBvYmplY3QgdXNlZCBpbiB0aGUgdGVtcGxhdGUgdG8gcmVzaXplIGltYWdlcy5cbiAgICovXG4gIHNpemU6IFNpemUgfCB1bmRlZmluZWQ7XG4gIC8qKlxuICAgKiBCb29sZWFuIHBhc3NlZCBhcyBpbnB1dCB0byBga3Mtd3JhcGAgZGlyZWN0aXZlIHRvIGNvbmZpZ3VyZSBmbGV4LXdyYXAgY3NzIHByb3BlcnR5LlxuICAgKiBIb3dldmVyIGl0J3Mgbm90IGVub3VnaCwgYmVjYXVzZSB5b3UgbmVlZCB0byBsaW1pdCB0aGUgd2lkdGggdXNpbmcgYHdpZHRoU3R5bGVgIHB1YmxpYyB2YXJpYWJsZS5cbiAgICogRm9yIG1vcmUgaW5mbyBjaGVjayBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9pdC9kb2NzL1dlYi9DU1MvZmxleC13cmFwXG4gICAqL1xuICB3cmFwU3R5bGUgPSBmYWxzZTtcbiAgLyoqXG4gICAqIFN0cmluZyBwYXNzZWQgYXMgaW5wdXQgdG8gYGtzLXdyYXBgIGRpcmVjdGl2ZSB0byBzZXQgd2lkdGggdG8gYmUgYWJsZSB0byBmb3JjZSBvdmVyZmxvdy5cbiAgICogSW4gdGhpcyB3YXksIGB3cmFwU3R5bGVgIChmbGV4LXdyYXAgY3NzIHByb3BlcnR5KSB3aWxsIGJlIHVzZWQgYXMgcmVxdWVzdGVkLlxuICAgKi9cbiAgd2lkdGhTdHlsZSA9ICcnO1xuICAvKipcbiAgICogU3RyaW5nIHBhc3NlZCBhcyBpbnB1dCB0byBga3MtZGlyZWN0aW9uYCBkaXJlY3RpdmUgdG8gc2V0IHRoZSBmbGV4LWRpcmVjdGlvbiBjc3MgcHJvcGVydHkuXG4gICAqIEZvciBtb3JlIGluZm8gY2hlY2sgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvaXQvZG9jcy9XZWIvQ1NTL2ZsZXgtZGlyZWN0aW9uXG4gICAqL1xuICBkaXJlY3Rpb25TdHlsZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuICAvKipcbiAgICogU3RyaW5nIHBhc3NlZCBhcyBpbnB1dCB0byBga3MtZGlyZWN0aW9uYCBkaXJlY3RpdmUgdG8gc2V0IHRoZSBqdXN0aWZ5LWNvbnRlbnQgY3NzIHByb3BlcnR5LlxuICAgKiBGb3IgbW9yZSBpbmZvIGNoZWNrIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2l0L2RvY3MvV2ViL0NTUy9qdXN0aWZ5LWNvbnRlbnRcbiAgICovXG4gIGp1c3RpZnlTdHlsZTogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgY29uZmlnU2VydmljZTogQ29uZmlnU2VydmljZSkge1xuICAgIHN1cGVyKCk7XG4gIH1cblxuICAvKipcbiAgICogTWV0aG9kIMK0bmdPbkluaXTCtCB0byBpbml0IGJvdGggYGNvbmZpZ1BsYWluR2FsbGVyeWAgY2FsbGluZyBgaW5pdFBsYWluR2FsbGVyeUNvbmZpZygpYFxuICAgKiBhbmQgYGltYWdlR3JpZCBpbnZva2luZyBgaW5pdEltYWdlR3JpZCgpYC5cbiAgICogVGhpcyBpcyBhbiBhbmd1bGFyIGxpZmVjeWNsZSBob29rLCBzbyBpdHMgY2FsbGVkIGF1dG9tYXRpY2FsbHkgYnkgQW5ndWxhciBpdHNlbGYuXG4gICAqIEluIHBhcnRpY3VsYXIsIGl0J3MgY2FsbGVkIG9ubHkgb25lIHRpbWUhISFcbiAgICovXG4gIG5nT25Jbml0KCk6IHZvaWQge1xuICAgIGlmICh0aGlzLmlkID09PSBudWxsIHx8IHRoaXMuaWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnRlcm5hbCBsaWJyYXJ5IGVycm9yIC0gaWQgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHRoaXMuY29uZmlnU2VydmljZS5zZXRDb25maWcodGhpcy5pZCwgdGhpcy5jb25maWcpO1xuXG4gICAgY29uc3QgbGliQ29uZmlnOiBMaWJDb25maWcgfCB1bmRlZmluZWQgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0Q29uZmlnKHRoaXMuaWQpO1xuICAgIGlmICghbGliQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGxpYnJhcnkgZXJyb3IgLSBsaWJDb25maWcgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuICAgIHRoaXMuYWNjZXNzaWJpbGl0eUNvbmZpZyA9IGxpYkNvbmZpZy5hY2Nlc3NpYmlsaXR5Q29uZmlnO1xuICAgIHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnID0gbGliQ29uZmlnLnBsYWluR2FsbGVyeUNvbmZpZztcbiAgICB0aGlzLmluaXRJbWFnZUdyaWQoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgwrRuZ09uQ2hhbmdlc8K0IHRvIHVwZGF0ZSBib3RoIGBpbWFnZUdyaWRgIGFuZGBwbGFpbkdhbGxlcnlDb25maWdgLlxuICAgKiBUaGlzIGlzIGFuIGFuZ3VsYXIgbGlmZWN5Y2xlIGhvb2ssIHNvIGl0cyBjYWxsZWQgYXV0b21hdGljYWxseSBieSBBbmd1bGFyIGl0c2VsZi5cbiAgICogSW4gcGFydGljdWxhciwgaXQncyBjYWxsZWQgd2hlbiBhbnkgZGF0YS1ib3VuZCBwcm9wZXJ0eSBvZiBhIGRpcmVjdGl2ZSBjaGFuZ2VzISEhXG4gICAqL1xuICBuZ09uQ2hhbmdlcyhjaGFuZ2VzOiBTaW1wbGVDaGFuZ2VzKTogdm9pZCB7XG4gICAgaWYgKHRoaXMuaWQgPT09IG51bGwgfHwgdGhpcy5pZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGxpYnJhcnkgZXJyb3IgLSBpZCBtdXN0IGJlIGRlZmluZWQnKTtcbiAgICB9XG4gICAgY29uc3QgbGliQ29uZmlnOiBMaWJDb25maWcgfCB1bmRlZmluZWQgPSB0aGlzLmNvbmZpZ1NlcnZpY2UuZ2V0Q29uZmlnKHRoaXMuaWQpO1xuICAgIGlmICghbGliQ29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGxpYnJhcnkgZXJyb3IgLSBsaWJDb25maWcgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgY29uc3QgaW1hZ2VzQ2hhbmdlOiBTaW1wbGVDaGFuZ2UgPSBjaGFuZ2VzLmltYWdlcztcbiAgICBjb25zdCBjb25maWdDaGFuZ2U6IFNpbXBsZUNoYW5nZSA9IGNoYW5nZXMuY29uZmlnO1xuICAgIC8vIEknbSB1c2luZyAhY2hhbmdlLmZpcnN0Q2hhbmdlIGJlY2F1c2UgdGhlIGZpcnN0IHRpbWUgd2lsbCBiZSBjYWxsZWQgYm90aCBvbkluaXQgYW5kIG9uQ2hhbmdlIGFuZCBJIGRvbid0XG4gICAgLy8gd2FudCB0byBleGVjdXRlIGluaXRpYWxpemF0aW9uIHR3byB0aW1lcy5cbiAgICBpZiAoXG4gICAgICBjb25maWdDaGFuZ2UgJiZcbiAgICAgICFjb25maWdDaGFuZ2UuZmlyc3RDaGFuZ2UgJiZcbiAgICAgIChjb25maWdDaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gY29uZmlnQ2hhbmdlLmN1cnJlbnRWYWx1ZSB8fCAoIWNvbmZpZ0NoYW5nZS5wcmV2aW91c1ZhbHVlICYmICFjb25maWdDaGFuZ2UuY3VycmVudFZhbHVlKSlcbiAgICApIHtcbiAgICAgIHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnID0gbGliQ29uZmlnLnBsYWluR2FsbGVyeUNvbmZpZztcbiAgICAgIC8vIHRoaXMuY29uZmlnUGxhaW5HYWxsZXJ5ID0gdGhpcy5pbml0UGxhaW5HYWxsZXJ5Q29uZmlnKCk7XG4gICAgfVxuICAgIGlmIChpbWFnZXNDaGFuZ2UgJiYgIWltYWdlc0NoYW5nZS5maXJzdENoYW5nZSAmJiBpbWFnZXNDaGFuZ2UucHJldmlvdXNWYWx1ZSAhPT0gaW1hZ2VzQ2hhbmdlLmN1cnJlbnRWYWx1ZSkge1xuICAgICAgdGhpcy5pbml0SW1hZ2VHcmlkKCk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgd2hlbiB5b3UgY2xpY2sgb24gYW4gaW1hZ2Ugb2YgdGhlIHBsYWluIChvciBpbmxpbmUpIGdhbGxlcnkuXG4gICAqIFRoaXMgd2lsbCBlbWl0IHRoZSBzaG93IGV2ZW50IHdpdGggdGhlIGltYWdlIGFzIHBheWxvYWQuXG4gICAqIEBwYXJhbSBJbWFnZSBpbWcgaXMgdGhlIEltYWdlIHRvIHNob3dcbiAgICovXG4gIHNob3dNb2RhbEdhbGxlcnlCeUltYWdlKGltZzogSW1hZ2UpOiB2b2lkIHtcbiAgICBjb25zdCBpbmRleDogbnVtYmVyID0gdGhpcy5pbWFnZXMuZmluZEluZGV4KCh2YWw6IEltYWdlKSA9PiB2YWwgJiYgaW1nICYmIHZhbC5pZCA9PT0gaW1nLmlkKTtcbiAgICB0aGlzLnNob3dNb2RhbEdhbGxlcnkoaW5kZXgpO1xuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCBjYWxsZWQgd2hlbiB5b3UgbmF2aWdhdGUgYmV0d2VlbiBpbWFnZXMuXG4gICAqIFRoaXMgd2lsbCBlbWl0IHRoZSBzaG93IGV2ZW50IHdpdGggdGhlIGltYWdlIGFzIHBheWxvYWQuXG4gICAqIEBwYXJhbSBLZXlib2FyZEV2ZW50IGV2ZW50IHRoYXQgdHJpZ2dlcmVkIHRoZSBuYXZpZ2F0aW9uXG4gICAqIEBwYXJhbSBJbWFnZSBpbWcgaXMgdGhlIEltYWdlIHRvIHNob3dcbiAgICovXG4gIG9uTmF2aWdhdGlvbkV2ZW50KGV2ZW50OiBLZXlib2FyZEV2ZW50LCBpbWc6IEltYWdlKTogdm9pZCB7XG4gICAgY29uc3QgcmVzdWx0OiBudW1iZXIgPSBzdXBlci5oYW5kbGVJbWFnZUV2ZW50KGV2ZW50KTtcbiAgICBpZiAocmVzdWx0ID09PSBORVhUKSB7XG4gICAgICB0aGlzLnNob3dNb2RhbEdhbGxlcnlCeUltYWdlKGltZyk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIE1ldGhvZCB0byBnZXQgYGFsdCBhdHRyaWJ1dGVgLlxuICAgKiBgYWx0YCBzcGVjaWZpZXMgYW4gYWx0ZXJuYXRlIHRleHQgZm9yIGFuIGltYWdlLCBpZiB0aGUgaW1hZ2UgY2Fubm90IGJlIGRpc3BsYXllZC5cbiAgICogQHBhcmFtIEltYWdlIGltYWdlIHRvIGdldCBpdHMgYWx0IGRlc2NyaXB0aW9uLlxuICAgKiBAcmV0dXJucyBzdHJpbmcgYWx0IGRlc2NyaXB0aW9uIG9mIHRoZSBpbWFnZVxuICAgKi9cbiAgZ2V0QWx0UGxhaW5EZXNjcmlwdGlvbkJ5SW1hZ2UoaW1hZ2U6IEltYWdlKTogc3RyaW5nIHtcbiAgICBpZiAoIWltYWdlKSB7XG4gICAgICByZXR1cm4gJyc7XG4gICAgfVxuICAgIHJldHVybiBpbWFnZS5wbGFpbiAmJiBpbWFnZS5wbGFpbi5kZXNjcmlwdGlvbiA/IGltYWdlLnBsYWluLmRlc2NyaXB0aW9uIDogYEltYWdlICR7Z2V0SW5kZXgoaW1hZ2UsIHRoaXMuaW1hZ2VzKSArIDF9YDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdG8gZ2V0IHRoZSB0aXRsZSBmb3IgYW4gaW1hZ2UuXG4gICAqIEBwYXJhbSBJbWFnZSBpbWFnZSB0byBnZXQgaXRzIHRpdGxlXG4gICAqIEByZXR1cm5zIHN0cmluZyB0aGUgdGl0bGUgb2YgdGhlIGlucHV0IGltYWdlXG4gICAqL1xuICBnZXRUaXRsZURpc3BsYXkoaW1hZ2U6IEltYWdlKTogc3RyaW5nIHtcbiAgICBsZXQgZGVzY3JpcHRpb24gPSAnJztcblxuICAgIGlmIChpbWFnZS5wbGFpbiAmJiBpbWFnZS5wbGFpbi5kZXNjcmlwdGlvbikge1xuICAgICAgZGVzY3JpcHRpb24gPSBpbWFnZS5wbGFpbi5kZXNjcmlwdGlvbjtcbiAgICB9IGVsc2UgaWYgKGltYWdlLm1vZGFsICYmIGltYWdlLm1vZGFsLmRlc2NyaXB0aW9uKSB7XG4gICAgICBkZXNjcmlwdGlvbiA9IGltYWdlLm1vZGFsLmRlc2NyaXB0aW9uO1xuICAgIH1cblxuICAgIGNvbnN0IGN1cnJlbnRJbmRleDogbnVtYmVyID0gZ2V0SW5kZXgoaW1hZ2UsIHRoaXMuaW1hZ2VzKTtcbiAgICBjb25zdCBwcmV2RGVzY3JpcHRpb246IHN0cmluZyA9ICdJbWFnZSAnICsgKGN1cnJlbnRJbmRleCArIDEpICsgJy8nICsgdGhpcy5pbWFnZXMubGVuZ3RoO1xuICAgIGxldCBjdXJySW1nRGVzY3JpcHRpb246IHN0cmluZyA9IGRlc2NyaXB0aW9uID8gZGVzY3JpcHRpb24gOiAnJztcblxuICAgIGlmIChjdXJySW1nRGVzY3JpcHRpb24gIT09ICcnKSB7XG4gICAgICBjdXJySW1nRGVzY3JpcHRpb24gPSAnIC0gJyArIGN1cnJJbWdEZXNjcmlwdGlvbjtcbiAgICB9XG4gICAgcmV0dXJuIHByZXZEZXNjcmlwdGlvbiArIGN1cnJJbWdEZXNjcmlwdGlvbjtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgdXNlZCBpbiB0aGUgdGVtcGxhdGUgdG8gdHJhY2sgaWRzIGluIG5nRm9yLlxuICAgKiBAcGFyYW0gbnVtYmVyIGluZGV4IG9mIHRoZSBhcnJheVxuICAgKiBAcGFyYW0gSW1hZ2UgaXRlbSBvZiB0aGUgYXJyYXlcbiAgICogQHJldHVybnMgbnVtYmVyIHRoZSBpZCBvZiB0aGUgaXRlbVxuICAgKi9cbiAgdHJhY2tCeUlkKGluZGV4OiBudW1iZXIsIGl0ZW06IEltYWdlKTogbnVtYmVyIHtcbiAgICByZXR1cm4gaXRlbS5pZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBNZXRob2QgY2FsbGVkIHdoZW4geW91IGNsaWNrIG9uIGFuIGltYWdlIG9mIHRoZSBwbGFpbiAob3IgaW5saW5lKSBnYWxsZXJ5LlxuICAgKiBUaGlzIHdpbGwgZW1pdCB0aGUgc2hvdyBldmVudCB3aXRoIHRoZSBpbmRleCBudW1iZXIgYXMgcGF5bG9hZC5cbiAgICogQHBhcmFtIG51bWJlciBpbmRleCBvZiB0aGUgY2xpY2tlZCBpbWFnZVxuICAgKi9cbiAgcHJpdmF0ZSBzaG93TW9kYWxHYWxsZXJ5KGluZGV4OiBudW1iZXIpOiB2b2lkIHtcbiAgICB0aGlzLmNsaWNrSW1hZ2UuZW1pdChpbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogUHJpdmF0ZSBtZXRob2QgdG8gaW5pdCBib3RoIGBpbWFnZUdyaWRgIGFuZCBvdGhlciBzdHlsZSB2YXJpYWJsZXMsXG4gICAqIGJhc2VkIG9uIHRoZSBsYXlvdXQgdHlwZS5cbiAgICovXG4gIHByaXZhdGUgaW5pdEltYWdlR3JpZCgpOiB2b2lkIHtcbiAgICBpZiAoIXRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludGVybmFsIGxpYnJhcnkgZXJyb3IgLSBwbGFpbkdhbGxlcnlDb25maWcgbXVzdCBiZSBkZWZpbmVkJyk7XG4gICAgfVxuXG4gICAgLy8gcmVzZXQgdGhlIGFycmF5IHRvIHByZXZlbnQgaXNzdWVzIGluIGNhc2Ugb2YgR3JpZExheW91dFxuICAgIHRoaXMuaW1hZ2VHcmlkID0gW107XG5cbiAgICBpZiAodGhpcy5wbGFpbkdhbGxlcnlDb25maWcubGF5b3V0IGluc3RhbmNlb2YgTGluZUxheW91dCkge1xuICAgICAgY29uc3QgbGF5b3V0OiBMaW5lTGF5b3V0ID0gdGhpcy5wbGFpbkdhbGxlcnlDb25maWcubGF5b3V0O1xuICAgICAgY29uc3Qgcm93OiBJbWFnZVtdID0gdGhpcy5pbWFnZXMuZmlsdGVyKCh2YWw6IEltYWdlLCBpOiBudW1iZXIpID0+IGkgPCBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoIHx8IGxheW91dC5icmVha0NvbmZpZy5sZW5ndGggPT09IC0xKTtcbiAgICAgIHRoaXMuaW1hZ2VHcmlkID0gW3Jvd107XG5cbiAgICAgIHRoaXMuc2l6ZSA9IHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnLmxheW91dC5zaXplO1xuXG4gICAgICBzd2l0Y2ggKHRoaXMucGxhaW5HYWxsZXJ5Q29uZmlnLnN0cmF0ZWd5KSB7XG4gICAgICAgIGNhc2UgUGxhaW5HYWxsZXJ5U3RyYXRlZ3kuUk9XOlxuICAgICAgICAgIHRoaXMuZGlyZWN0aW9uU3R5bGUgPSAncm93JztcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBQbGFpbkdhbGxlcnlTdHJhdGVneS5DT0xVTU46XG4gICAgICAgICAgdGhpcy5kaXJlY3Rpb25TdHlsZSA9ICdjb2x1bW4nO1xuICAgICAgICAgIHRoaXMud3JhcFN0eWxlID0gbGF5b3V0LmJyZWFrQ29uZmlnLndyYXA7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICB0aGlzLmp1c3RpZnlTdHlsZSA9IGxheW91dC5qdXN0aWZ5O1xuICAgIH1cblxuICAgIGlmICh0aGlzLnBsYWluR2FsbGVyeUNvbmZpZy5sYXlvdXQgaW5zdGFuY2VvZiBHcmlkTGF5b3V0KSB7XG4gICAgICBjb25zdCBsYXlvdXQ6IEdyaWRMYXlvdXQgPSB0aGlzLnBsYWluR2FsbGVyeUNvbmZpZy5sYXlvdXQ7XG4gICAgICBjb25zdCBjb3VudDogbnVtYmVyID0gTWF0aC5jZWlsKHRoaXMuaW1hZ2VzLmxlbmd0aCAvIGxheW91dC5icmVha0NvbmZpZy5sZW5ndGgpO1xuICAgICAgbGV0IHN0YXJ0ID0gMDtcbiAgICAgIGxldCBlbmQ6IG51bWJlciA9IGxheW91dC5icmVha0NvbmZpZy5sZW5ndGggLSAxO1xuXG4gICAgICBmb3IgKGxldCBqID0gMDsgaiA8IGNvdW50OyBqKyspIHtcbiAgICAgICAgY29uc3Qgcm93OiBJbWFnZVtdID0gdGhpcy5pbWFnZXMuZmlsdGVyKCh2YWw6IEltYWdlLCBpOiBudW1iZXIpID0+IGkgPj0gc3RhcnQgJiYgaSA8PSBlbmQpO1xuICAgICAgICB0aGlzLmltYWdlR3JpZC5wdXNoKHJvdyk7XG4gICAgICAgIHN0YXJ0ID0gZW5kICsgMTtcbiAgICAgICAgZW5kID0gc3RhcnQgKyBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoIC0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zaXplID0gdGhpcy5wbGFpbkdhbGxlcnlDb25maWcubGF5b3V0LnNpemU7XG5cbiAgICAgIGNvbnN0IHBpeGVsczogbnVtYmVyID0gK2xheW91dC5zaXplLndpZHRoLnJlcGxhY2UoJ3B4JywgJycpO1xuXG4gICAgICB0aGlzLndpZHRoU3R5bGUgPSBwaXhlbHMgKiBsYXlvdXQuYnJlYWtDb25maWcubGVuZ3RoICsgcGl4ZWxzIC8gMiArICdweCc7XG4gICAgICB0aGlzLndyYXBTdHlsZSA9IGxheW91dC5icmVha0NvbmZpZy53cmFwO1xuXG4gICAgICB0aGlzLmRpcmVjdGlvblN0eWxlID0gJ3Jvdyc7XG4gICAgfVxuICB9XG59XG4iLCI8ZGl2IGNsYXNzPVwicGxhaW4tY29udGFpbmVyXCJcbiAgICAga3NXcmFwIFt3cmFwXT1cIndyYXBTdHlsZVwiIFt3aWR0aF09XCJ3aWR0aFN0eWxlXCJcbiAgICAga3NEaXJlY3Rpb24gW2RpcmVjdGlvbl09XCJkaXJlY3Rpb25TdHlsZVwiIFtqdXN0aWZ5XT1cImp1c3RpZnlTdHlsZVwiXG4gICAgIFthdHRyLmFyaWEtbGFiZWxdPVwiYWNjZXNzaWJpbGl0eUNvbmZpZz8ucGxhaW5HYWxsZXJ5Q29udGVudEFyaWFMYWJlbFwiXG4gICAgIFt0aXRsZV09XCJhY2Nlc3NpYmlsaXR5Q29uZmlnPy5wbGFpbkdhbGxlcnlDb250ZW50VGl0bGVcIj5cblxuICA8bmctY29udGFpbmVyICpuZ0Zvcj1cImxldCBpbWdSb3cgb2YgaW1hZ2VHcmlkOyBsZXQgaSA9IGluZGV4XCI+XG4gICAgPG5nLWNvbnRhaW5lciAqbmdGb3I9XCJsZXQgaW1nQ29sIG9mIGltZ1JvdzsgbGV0IGogPSBpbmRleFwiPlxuXG4gICAgICA8bmctY29udGFpbmVyICpuZ0lmPVwiIXBsYWluR2FsbGVyeUNvbmZpZz8uYWR2YW5jZWQ/LmFUYWdzOyBlbHNlIGFUYWdzXCI+XG4gICAgICAgIDxpbWcgKm5nSWY9XCJpbWdDb2w/Lm1vZGFsPy5pbWdcIlxuICAgICAgICAgICAgIFtsb2FkaW5nXT1cImltZ0NvbC5sb2FkaW5nXCJcbiAgICAgICAgICAgICBbYXR0ci5mZXRjaHByaW9yaXR5XT1cImltZ0NvbC5mZXRjaHByaW9yaXR5XCJcbiAgICAgICAgICAgICBbc3JjXT1cImltZ0NvbC5wbGFpbj8uaW1nISA/IGltZ0NvbC5wbGFpbj8uaW1nISA6IGltZ0NvbC5tb2RhbC5pbWdcIlxuICAgICAgICAgICAgIGtzRmFsbGJhY2tJbWFnZSBbZmFsbGJhY2tJbWddPVwiaW1nQ29sLnBsYWluPy5mYWxsYmFja0ltZyA/IGltZ0NvbC5wbGFpbj8uZmFsbGJhY2tJbWcgOiBpbWdDb2wubW9kYWwuZmFsbGJhY2tJbWdcIlxuICAgICAgICAgICAgIGNsYXNzPVwiaW1hZ2VcIlxuICAgICAgICAgICAgIGtzU2l6ZSBbc2l6ZUNvbmZpZ109XCJ7d2lkdGg6IHNpemU/LndpZHRoISwgaGVpZ2h0OiBzaXplPy5oZWlnaHQhfVwiXG4gICAgICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJpbWdDb2wucGxhaW4/LmFyaWFMYWJlbFwiXG4gICAgICAgICAgICAgW3RpdGxlXT1cIihpbWdDb2wucGxhaW4/LnRpdGxlIHx8IGltZ0NvbC5wbGFpbj8udGl0bGUgPT09ICcnKSA/IGltZ0NvbC5wbGFpbj8udGl0bGUgOiBnZXRUaXRsZURpc3BsYXkoaW1nQ29sKVwiXG4gICAgICAgICAgICAgYWx0PVwie3tpbWdDb2wucGxhaW4/LmFsdCEgPyBpbWdDb2wucGxhaW4/LmFsdCEgOiBnZXRBbHRQbGFpbkRlc2NyaXB0aW9uQnlJbWFnZShpbWdDb2wpfX1cIlxuICAgICAgICAgICAgIFt0YWJJbmRleF09XCIwXCIgcm9sZT1cImltZ1wiXG4gICAgICAgICAgICAgKGNsaWNrKT1cInNob3dNb2RhbEdhbGxlcnlCeUltYWdlKGltZ0NvbClcIiAoa2V5dXApPVwib25OYXZpZ2F0aW9uRXZlbnQoJGV2ZW50LCBpbWdDb2wpXCIvPlxuICAgICAgPC9uZy1jb250YWluZXI+XG5cbiAgICAgIDwhLS0gQWRkIGRpcmVjdGl2ZSB0byBzZXQgYmFja2dyb3VuZCB3aXRoIHRoZSBpbWFnZSB1cmwgYXMgcGFyYW0gdG8gcGFzcyB0aHVtYiBvciBpbWctLT5cbiAgICAgIDwhLS0gdG8gZG8gc29tZXRoaW5nIGxpa2UgdGhpcyA8YSBzdHlsZT1cImJhY2tncm91bmQ6IHVybCgncGF0aCB0byBpbWFnZScpIDUwJSA1MCUvY292ZXJcIj4uLS0+XG4gICAgICA8bmctdGVtcGxhdGUgI2FUYWdzPlxuICAgICAgICA8YSAqbmdJZj1cImltZ0NvbD8ubW9kYWw/LmltZ1wiXG4gICAgICAgICAgIGNsYXNzPVwiYS10YWctaW1hZ2VcIlxuICAgICAgICAgICBrc0FUYWdCZ0ltYWdlIFtpbWFnZV09XCJpbWdDb2xcIiBbc3R5bGVdPVwicGxhaW5HYWxsZXJ5Q29uZmlnPy5hZHZhbmNlZD8uYWRkaXRpb25hbEJhY2tncm91bmRcIlxuICAgICAgICAgICBrc1NpemUgW3NpemVDb25maWddPVwie3dpZHRoOiBzaXplPy53aWR0aCEsIGhlaWdodDogc2l6ZT8uaGVpZ2h0IX1cIlxuICAgICAgICAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImltZ0NvbC5wbGFpbj8uYXJpYUxhYmVsXCJcbiAgICAgICAgICAgW3RpdGxlXT1cIihpbWdDb2wucGxhaW4/LnRpdGxlIHx8IGltZ0NvbC5wbGFpbj8udGl0bGUgPT09ICcnKSA/IGltZ0NvbC5wbGFpbj8udGl0bGUgOiBnZXRUaXRsZURpc3BsYXkoaW1nQ29sKVwiXG4gICAgICAgICAgIFt0YWJJbmRleF09XCIwXCJcbiAgICAgICAgICAgKGNsaWNrKT1cInNob3dNb2RhbEdhbGxlcnlCeUltYWdlKGltZ0NvbClcIiAoa2V5dXApPVwib25OYXZpZ2F0aW9uRXZlbnQoJGV2ZW50LCBpbWdDb2wpXCI+PC9hPlxuICAgICAgPC9uZy10ZW1wbGF0ZT5cblxuICAgIDwvbmctY29udGFpbmVyPlxuICA8L25nLWNvbnRhaW5lcj5cblxuPC9kaXY+XG5cbiJdfQ==