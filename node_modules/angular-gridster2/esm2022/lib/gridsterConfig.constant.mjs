import { CompactType, DirTypes, DisplayGrid, GridType } from './gridsterConfig.interface';
export const GridsterConfigService = {
    gridType: GridType.Fit, // 'fit' will fit the items in the container without scroll;
    scale: 1, // scale param to zoom in/zoom out
    // 'scrollVertical' will fit on width and height of the items will be the same as the width
    // 'scrollHorizontal' will fit on height and width of the items will be the same as the height
    // 'fixed' will set the rows and columns dimensions based on fixedColWidth and fixedRowHeight options
    // 'verticalFixed' will set the rows to fixedRowHeight and columns width will fit the space available
    // 'horizontalFixed' will set the columns to fixedColWidth and rows height will fit the space available
    fixedColWidth: 250, // fixed col width for gridType: 'fixed'
    fixedRowHeight: 250, // fixed row height for gridType: 'fixed'
    keepFixedHeightInMobile: false, // keep the height from fixed gridType in mobile layout
    keepFixedWidthInMobile: false, // keep the width from fixed gridType in mobile layout
    setGridSize: false, // sets grid size depending on content
    compactType: CompactType.None, // compact items: 'none' | 'compactUp' | 'compactLeft' | 'compactUp&Left' | 'compactLeft&Up'
    mobileBreakpoint: 640, // if the screen is not wider that this, remove the grid layout and stack the items
    useBodyForBreakpoint: false, // whether to use the body width to determine the mobile breakpoint. Uses the element width when false.
    allowMultiLayer: false,
    defaultLayerIndex: 0,
    maxLayerIndex: 2,
    baseLayerIndex: 1,
    minCols: 1, // minimum amount of columns in the grid
    maxCols: 100, // maximum amount of columns in the grid
    minRows: 1, // minimum amount of rows in the grid
    maxRows: 100, // maximum amount of rows in the grid
    defaultItemCols: 1, // default width of an item in columns
    defaultItemRows: 1, // default height of an item in rows
    maxItemCols: 50, // max item number of cols
    maxItemRows: 50, // max item number of rows
    minItemCols: 1, // min item number of columns
    minItemRows: 1, // min item number of rows
    minItemArea: 1, // min item area: cols * rows
    maxItemArea: 2500, // max item area: cols * rows
    addEmptyRowsCount: 0, // add a number of extra empty rows at the end
    rowHeightRatio: 1, // row height ratio from column width
    margin: 10, // margin between grid items
    outerMargin: true, // if margins will apply to the sides of the container
    outerMarginTop: null, // override outer margin for grid
    outerMarginRight: null, // override outer margin for grid
    outerMarginBottom: null, // override outer margin for grid
    outerMarginLeft: null, // override outer margin for grid
    useTransformPositioning: true, // toggle between transform or top/left positioning of items
    scrollSensitivity: 10, // margin of the dashboard where to start scrolling
    scrollSpeed: 20, // how much to scroll each mouse move when in the scrollSensitivity zone
    initCallback: undefined, // callback to call after grid has initialized. Arguments: gridsterComponent
    destroyCallback: undefined, // callback to call after grid has destroyed. Arguments: gridsterComponent
    gridSizeChangedCallback: undefined, // callback to call after grid has changed size. Arguments: gridsterComponent
    itemChangeCallback: undefined, // callback to call for each item when is changes x, y, rows, cols.
    // Arguments: gridsterItem, gridsterItemComponent
    itemResizeCallback: undefined, // callback to call for each item when width/height changes.
    // Arguments: gridsterItem, gridsterItemComponent
    itemInitCallback: undefined, // callback to call for each item when is initialized.
    // Arguments: gridsterItem, gridsterItemComponent
    itemRemovedCallback: undefined, // callback to call for each item when is initialized.
    // Arguments: gridsterItem, gridsterItemComponent
    itemValidateCallback: undefined, // callback to call to validate item position/size. Return true if valid.
    // Arguments: gridsterItem
    enableEmptyCellClick: false, // enable empty cell click events
    enableEmptyCellContextMenu: false, // enable empty cell context menu (right click) events
    enableEmptyCellDrop: false, // enable empty cell drop events
    enableEmptyCellDrag: false, // enable empty cell drag events
    enableOccupiedCellDrop: false, // enable occupied cell drop events
    emptyCellClickCallback: undefined, // empty cell click callback
    emptyCellContextMenuCallback: undefined, // empty cell context menu (right click) callback
    emptyCellDropCallback: undefined, // empty cell drag drop callback. HTML5 Drag & Drop
    emptyCellDragCallback: undefined, // empty cell drag and create item like excel cell selection
    emptyCellDragMaxCols: 50, // limit empty cell drag max cols
    emptyCellDragMaxRows: 50, // limit empty cell drag max rows
    // Arguments: event, gridsterItem{x, y, rows: defaultItemRows, cols: defaultItemCols}
    ignoreMarginInRow: false, // ignore the gap between rows for items which span multiple rows (see #162, #224)
    draggable: {
        delayStart: 0, // milliseconds to delay the start of drag, useful for touch interaction
        enabled: false, // enable/disable draggable items
        ignoreContentClass: 'gridster-item-content', // default content class to ignore the drag event from
        ignoreContent: false, // if true drag will start only from elements from `dragHandleClass`
        dragHandleClass: 'drag-handler', // drag event only from this class. If `ignoreContent` is true.
        stop: undefined, // callback when dragging an item stops.  Accepts Promise return to cancel/approve drag.
        start: undefined, // callback when dragging an item starts.
        // Arguments: item, gridsterItem, event
        dropOverItems: false, // enable drop items on top other item
        dropOverItemsCallback: undefined // callback on drop over another item
        // Arguments: source, target, gridComponent
    },
    resizable: {
        delayStart: 0, // milliseconds to delay the start of resize, useful for touch interaction
        enabled: false, // enable/disable resizable items
        handles: {
            s: true,
            e: true,
            n: true,
            w: true,
            se: true,
            ne: true,
            sw: true,
            nw: true
        }, // resizable edges of an item
        stop: undefined, // callback when resizing an item stops. Accepts Promise return to cancel/approve resize.
        start: undefined // callback when resizing an item starts.
        // Arguments: item, gridsterItem, event
    },
    swap: true, // allow items to switch position if drop on top of another
    swapWhileDragging: false, // allow items to switch position while dragging
    pushItems: false, // push items when resizing and dragging
    disablePushOnDrag: false, // disable push on drag
    disablePushOnResize: false, // disable push on resize
    pushDirections: { north: true, east: true, south: true, west: true }, // control the directions items are pushed
    pushResizeItems: false, // on resize of item will shrink adjacent items
    displayGrid: DisplayGrid.OnDragAndResize, // display background grid of rows and columns
    disableWindowResize: false, // disable the window on resize listener. This will stop grid to recalculate on window resize.
    disableWarnings: false, // disable console log warnings about misplacement of grid items
    scrollToNewItems: false, // scroll to new items placed in a scrollable view
    disableScrollHorizontal: false, // disable horizontal scrolling
    disableScrollVertical: false, // disable vertical scrolling
    enableBoundaryControl: false, // enable boundary control while dragging items
    disableAutoPositionOnConflict: false, // disable auto-position of items on conflict state,
    dirType: DirTypes.LTR // page direction, rtl=right to left ltr= left to right, if you use rtl language set dirType to rtl
};
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZ3JpZHN0ZXJDb25maWcuY29uc3RhbnQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyLWdyaWRzdGVyMi9zcmMvbGliL2dyaWRzdGVyQ29uZmlnLmNvbnN0YW50LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFDTCxXQUFXLEVBQ1gsUUFBUSxFQUNSLFdBQVcsRUFFWCxRQUFRLEVBQ1QsTUFBTSw0QkFBNEIsQ0FBQztBQUVwQyxNQUFNLENBQUMsTUFBTSxxQkFBcUIsR0FBbUI7SUFDbkQsUUFBUSxFQUFFLFFBQVEsQ0FBQyxHQUFHLEVBQUUsNERBQTREO0lBQ3BGLEtBQUssRUFBRSxDQUFDLEVBQUUsa0NBQWtDO0lBQzVDLDJGQUEyRjtJQUMzRiw4RkFBOEY7SUFDOUYscUdBQXFHO0lBQ3JHLHFHQUFxRztJQUNyRyx1R0FBdUc7SUFDdkcsYUFBYSxFQUFFLEdBQUcsRUFBRSx3Q0FBd0M7SUFDNUQsY0FBYyxFQUFFLEdBQUcsRUFBRSx5Q0FBeUM7SUFDOUQsdUJBQXVCLEVBQUUsS0FBSyxFQUFFLHVEQUF1RDtJQUN2RixzQkFBc0IsRUFBRSxLQUFLLEVBQUUsc0RBQXNEO0lBQ3JGLFdBQVcsRUFBRSxLQUFLLEVBQUUsc0NBQXNDO0lBQzFELFdBQVcsRUFBRSxXQUFXLENBQUMsSUFBSSxFQUFFLDRGQUE0RjtJQUMzSCxnQkFBZ0IsRUFBRSxHQUFHLEVBQUUsbUZBQW1GO0lBQzFHLG9CQUFvQixFQUFFLEtBQUssRUFBRSx1R0FBdUc7SUFDcEksZUFBZSxFQUFFLEtBQUs7SUFDdEIsaUJBQWlCLEVBQUUsQ0FBQztJQUNwQixhQUFhLEVBQUUsQ0FBQztJQUNoQixjQUFjLEVBQUUsQ0FBQztJQUNqQixPQUFPLEVBQUUsQ0FBQyxFQUFFLHdDQUF3QztJQUNwRCxPQUFPLEVBQUUsR0FBRyxFQUFFLHdDQUF3QztJQUN0RCxPQUFPLEVBQUUsQ0FBQyxFQUFFLHFDQUFxQztJQUNqRCxPQUFP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RSwrQ0FBK0M7SUFDN0UsNkJBQTZCLEVBQUUsS0FBSyxFQUFFLG9EQUFvRDtJQUMxRixPQUFPLEVBQUUsUUFBUSxDQUFDLEdBQUcsQ0FBQyxtR0FBbUc7Q0FDMUgsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7XG4gIENvbXBhY3RUeXBlLFxuICBEaXJUeXBlcyxcbiAgRGlzcGxheUdyaWQsXG4gIEdyaWRzdGVyQ29uZmlnLFxuICBHcmlkVHlwZVxufSBmcm9tICcuL2dyaWRzdGVyQ29uZmlnLmludGVyZmFjZSc7XG5cbmV4cG9ydCBjb25zdCBHcmlkc3RlckNvbmZpZ1NlcnZpY2U6IEdyaWRzdGVyQ29uZmlnID0ge1xuICBncmlkVHlwZTogR3JpZFR5cGUuRml0LCAvLyAnZml0JyB3aWxsIGZpdCB0aGUgaXRlbXMgaW4gdGhlIGNvbnRhaW5lciB3aXRob3V0IHNjcm9sbDtcbiAgc2NhbGU6IDEsIC8vIHNjYWxlIHBhcmFtIHRvIHpvb20gaW4vem9vbSBvdXRcbiAgLy8gJ3Njcm9sbFZlcnRpY2FsJyB3aWxsIGZpdCBvbiB3aWR0aCBhbmQgaGVpZ2h0IG9mIHRoZSBpdGVtcyB3aWxsIGJlIHRoZSBzYW1lIGFzIHRoZSB3aWR0aFxuICAvLyAnc2Nyb2xsSG9yaXpvbnRhbCcgd2lsbCBmaXQgb24gaGVpZ2h0IGFuZCB3aWR0aCBvZiB0aGUgaXRlbXMgd2lsbCBiZSB0aGUgc2FtZSBhcyB0aGUgaGVpZ2h0XG4gIC8vICdmaXhlZCcgd2lsbCBzZXQgdGhlIHJvd3MgYW5kIGNvbHVtbnMgZGltZW5zaW9ucyBiYXNlZCBvbiBmaXhlZENvbFdpZHRoIGFuZCBmaXhlZFJvd0hlaWdodCBvcHRpb25zXG4gIC8vICd2ZXJ0aWNhbEZpeGVkJyB3aWxsIHNldCB0aGUgcm93cyB0byBmaXhlZFJvd0hlaWdodCBhbmQgY29sdW1ucyB3aWR0aCB3aWxsIGZpdCB0aGUgc3BhY2UgYXZhaWxhYmxlXG4gIC8vICdob3Jpem9udGFsRml4ZWQnIHdpbGwgc2V0IHRoZSBjb2x1bW5zIHRvIGZpeGVkQ29sV2lkdGggYW5kIHJvd3MgaGVpZ2h0IHdpbGwgZml0IHRoZSBzcGFjZSBhdmFpbGFibGVcbiAgZml4ZWRDb2xXaWR0aDogMjUwLCAvLyBmaXhlZCBjb2wgd2lkdGggZm9yIGdyaWRUeXBlOiAnZml4ZWQnXG4gIGZpeGVkUm93SGVpZ2h0OiAyNTAsIC8vIGZpeGVkIHJvdyBoZWlnaHQgZm9yIGdyaWRUeXBlOiAnZml4ZWQnXG4gIGtlZXBGaXhlZEhlaWdodEluTW9iaWxlOiBmYWxzZSwgLy8ga2VlcCB0aGUgaGVpZ2h0IGZyb20gZml4ZWQgZ3JpZFR5cGUgaW4gbW9iaWxlIGxheW91dFxuICBrZWVwRml4ZWRXaWR0aEluTW9iaWxlOiBmYWxzZSwgLy8ga2VlcCB0aGUgd2lkdGggZnJvbSBmaXhlZCBncmlkVHlwZSBpbiBtb2JpbGUgbGF5b3V0XG4gIHNldEdyaWRTaXplOiBmYWxzZSwgLy8gc2V0cyBncmlkIHNpemUgZGVwZW5kaW5nIG9uIGNvbnRlbnRcbiAgY29tcGFjdFR5cGU6IENvbXBhY3RUeXBlLk5vbmUsIC8vIGNvbXBhY3QgaXRlbXM6ICdub25lJyB8ICdjb21wYWN0VXAnIHwgJ2NvbXBhY3RMZWZ0JyB8ICdjb21wYWN0VXAmTGVmdCcgfCAnY29tcGFjdExlZnQmVXAnXG4gIG1vYmlsZUJyZWFrcG9pbnQ6IDY0MCwgLy8gaWYgdGhlIHNjcmVlbiBpcyBub3Qgd2lkZXIgdGhhdCB0aGlzLCByZW1vdmUgdGhlIGdyaWQgbGF5b3V0IGFuZCBzdGFjayB0aGUgaXRlbXNcbiAgdXNlQm9keUZvckJyZWFrcG9pbnQ6IGZhbHNlLCAvLyB3aGV0aGVyIHRvIHVzZSB0aGUgYm9keSB3aWR0aCB0byBkZXRlcm1pbmUgdGhlIG1vYmlsZSBicmVha3BvaW50LiBVc2VzIHRoZSBlbGVtZW50IHdpZHRoIHdoZW4gZmFsc2UuXG4gIGFsbG93TXVsdGlMYXllcjogZmFsc2UsXG4gIGRlZmF1bHRMYXllckluZGV4OiAwLFxuICBtYXhMYXllckluZGV4OiAyLFxuICBiYXNlTGF5ZXJJbmRleDogMSxcbiAgbWluQ29sczogMSwgLy8gbWluaW11bSBhbW91bnQgb2YgY29sdW1ucyBpbiB0aGUgZ3JpZFxuICBtYXhDb2xzOiAxMDAsIC8vIG1heGltdW0gYW1vdW50IG9mIGNvbHVtbnMgaW4gdGhlIGdyaWRcbiAgbWluUm93czogMSwgLy8gbWluaW11bSBhbW91bnQgb2Ygcm93cyBpbiB0aGUgZ3JpZFxuICBtYXhSb3dzOiAxMDAsIC8vIG1heGltdW0gYW1vdW50IG9mIHJvd3MgaW4gdGhlIGdyaWRcbiAgZGVmYXVsdEl0ZW1Db2xzOiAxLCAvLyBkZWZhdWx0IHdpZHRoIG9mIGFuIGl0ZW0gaW4gY29sdW1uc1xuICBkZWZhdWx0SXRlbVJvd3M6IDEsIC8vIGRlZmF1bHQgaGVpZ2h0IG9mIGFuIGl0ZW0gaW4gcm93c1xuICBtYXhJdGVtQ29sczogNTAsIC8vIG1heCBpdGVtIG51bWJlciBvZiBjb2xzXG4gIG1heEl0ZW1Sb3dzOiA1MCwgLy8gbWF4IGl0ZW0gbnVtYmVyIG9mIHJvd3NcbiAgbWluSXRlbUNvbHM6IDEsIC8vIG1pbiBpdGVtIG51bWJlciBvZiBjb2x1bW5zXG4gIG1pbkl0ZW1Sb3dzOiAxLCAvLyBtaW4gaXRlbSBudW1iZXIgb2Ygcm93c1xuICBtaW5JdGVtQXJlYTogMSwgLy8gbWluIGl0ZW0gYXJlYTogY29scyAqIHJvd3NcbiAgbWF4SXRlbUFyZWE6IDI1MDAsIC8vIG1heCBpdGVtIGFyZWE6IGNvbHMgKiByb3dzXG4gIGFkZEVtcHR5Um93c0NvdW50OiAwLCAvLyBhZGQgYSBudW1iZXIgb2YgZXh0cmEgZW1wdHkgcm93cyBhdCB0aGUgZW5kXG4gIHJvd0hlaWdodFJhdGlvOiAxLCAvLyByb3cgaGVpZ2h0IHJhdGlvIGZyb20gY29sdW1uIHdpZHRoXG4gIG1hcmdpbjogMTAsIC8vIG1hcmdpbiBiZXR3ZWVuIGdyaWQgaXRlbXNcbiAgb3V0ZXJNYXJnaW46IHRydWUsIC8vIGlmIG1hcmdpbnMgd2lsbCBhcHBseSB0byB0aGUgc2lkZXMgb2YgdGhlIGNvbnRhaW5lclxuICBvdXRlck1hcmdpblRvcDogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIG91dGVyTWFyZ2luUmlnaHQ6IG51bGwsIC8vIG92ZXJyaWRlIG91dGVyIG1hcmdpbiBmb3IgZ3JpZFxuICBvdXRlck1hcmdpbkJvdHRvbTogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIG91dGVyTWFyZ2luTGVmdDogbnVsbCwgLy8gb3ZlcnJpZGUgb3V0ZXIgbWFyZ2luIGZvciBncmlkXG4gIHVzZVRyYW5zZm9ybVBvc2l0aW9uaW5nOiB0cnVlLCAvLyB0b2dnbGUgYmV0d2VlbiB0cmFuc2Zvcm0gb3IgdG9wL2xlZnQgcG9zaXRpb25pbmcgb2YgaXRlbXNcbiAgc2Nyb2xsU2Vuc2l0aXZpdHk6IDEwLCAvLyBtYXJnaW4gb2YgdGhlIGRhc2hib2FyZCB3aGVyZSB0byBzdGFydCBzY3JvbGxpbmdcbiAgc2Nyb2xsU3BlZWQ6IDIwLCAvLyBob3cgbXVjaCB0byBzY3JvbGwgZWFjaCBtb3VzZSBtb3ZlIHdoZW4gaW4gdGhlIHNjcm9sbFNlbnNpdGl2aXR5IHpvbmVcbiAgaW5pdENhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIHRvIGNhbGwgYWZ0ZXIgZ3JpZCBoYXMgaW5pdGlhbGl6ZWQuIEFyZ3VtZW50czogZ3JpZHN0ZXJDb21wb25lbnRcbiAgZGVzdHJveUNhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIHRvIGNhbGwgYWZ0ZXIgZ3JpZCBoYXMgZGVzdHJveWVkLiBBcmd1bWVudHM6IGdyaWRzdGVyQ29tcG9uZW50XG4gIGdyaWRTaXplQ2hhbmdlZENhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIHRvIGNhbGwgYWZ0ZXIgZ3JpZCBoYXMgY2hhbmdlZCBzaXplLiBBcmd1bWVudHM6IGdyaWRzdGVyQ29tcG9uZW50XG4gIGl0ZW1DaGFuZ2VDYWxsYmFjazogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiBpcyBjaGFuZ2VzIHgsIHksIHJvd3MsIGNvbHMuXG4gIC8vIEFyZ3VtZW50czogZ3JpZHN0ZXJJdGVtLCBncmlkc3Rlckl0ZW1Db21wb25lbnRcbiAgaXRlbVJlc2l6ZUNhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIHRvIGNhbGwgZm9yIGVhY2ggaXRlbSB3aGVuIHdpZHRoL2hlaWdodCBjaGFuZ2VzLlxuICAvLyBBcmd1bWVudHM6IGdyaWRzdGVySXRlbSwgZ3JpZHN0ZXJJdGVtQ29tcG9uZW50XG4gIGl0ZW1Jbml0Q2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gY2FsbGJhY2sgdG8gY2FsbCBmb3IgZWFjaCBpdGVtIHdoZW4gaXMgaW5pdGlhbGl6ZWQuXG4gIC8vIEFyZ3VtZW50czogZ3JpZHN0ZXJJdGVtLCBncmlkc3Rlckl0ZW1Db21wb25lbnRcbiAgaXRlbVJlbW92ZWRDYWxsYmFjazogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB0byBjYWxsIGZvciBlYWNoIGl0ZW0gd2hlbiBpcyBpbml0aWFsaXplZC5cbiAgLy8gQXJndW1lbnRzOiBncmlkc3Rlckl0ZW0sIGdyaWRzdGVySXRlbUNvbXBvbmVudFxuICBpdGVtVmFsaWRhdGVDYWxsYmFjazogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB0byBjYWxsIHRvIHZhbGlkYXRlIGl0ZW0gcG9zaXRpb24vc2l6ZS4gUmV0dXJuIHRydWUgaWYgdmFsaWQuXG4gIC8vIEFyZ3VtZW50czogZ3JpZHN0ZXJJdGVtXG4gIGVuYWJsZUVtcHR5Q2VsbENsaWNrOiBmYWxzZSwgLy8gZW5hYmxlIGVtcHR5IGNlbGwgY2xpY2sgZXZlbnRzXG4gIGVuYWJsZUVtcHR5Q2VsbENvbnRleHRNZW51OiBmYWxzZSwgLy8gZW5hYmxlIGVtcHR5IGNlbGwgY29udGV4dCBtZW51IChyaWdodCBjbGljaykgZXZlbnRzXG4gIGVuYWJsZUVtcHR5Q2VsbERyb3A6IGZhbHNlLCAvLyBlbmFibGUgZW1wdHkgY2VsbCBkcm9wIGV2ZW50c1xuICBlbmFibGVFbXB0eUNlbGxEcmFnOiBmYWxzZSwgLy8gZW5hYmxlIGVtcHR5IGNlbGwgZHJhZyBldmVudHNcbiAgZW5hYmxlT2NjdXBpZWRDZWxsRHJvcDogZmFsc2UsIC8vIGVuYWJsZSBvY2N1cGllZCBjZWxsIGRyb3AgZXZlbnRzXG4gIGVtcHR5Q2VsbENsaWNrQ2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gZW1wdHkgY2VsbCBjbGljayBjYWxsYmFja1xuICBlbXB0eUNlbGxDb250ZXh0TWVudUNhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGVtcHR5IGNlbGwgY29udGV4dCBtZW51IChyaWdodCBjbGljaykgY2FsbGJhY2tcbiAgZW1wdHlDZWxsRHJvcENhbGxiYWNrOiB1bmRlZmluZWQsIC8vIGVtcHR5IGNlbGwgZHJhZyBkcm9wIGNhbGxiYWNrLiBIVE1MNSBEcmFnICYgRHJvcFxuICBlbXB0eUNlbGxEcmFnQ2FsbGJhY2s6IHVuZGVmaW5lZCwgLy8gZW1wdHkgY2VsbCBkcmFnIGFuZCBjcmVhdGUgaXRlbSBsaWtlIGV4Y2VsIGNlbGwgc2VsZWN0aW9uXG4gIGVtcHR5Q2VsbERyYWdNYXhDb2xzOiA1MCwgLy8gbGltaXQgZW1wdHkgY2VsbCBkcmFnIG1heCBjb2xzXG4gIGVtcHR5Q2VsbERyYWdNYXhSb3dzOiA1MCwgLy8gbGltaXQgZW1wdHkgY2VsbCBkcmFnIG1heCByb3dzXG4gIC8vIEFyZ3VtZW50czogZXZlbnQsIGdyaWRzdGVySXRlbXt4LCB5LCByb3dzOiBkZWZhdWx0SXRlbVJvd3MsIGNvbHM6IGRlZmF1bHRJdGVtQ29sc31cbiAgaWdub3JlTWFyZ2luSW5Sb3c6IGZhbHNlLCAvLyBpZ25vcmUgdGhlIGdhcCBiZXR3ZWVuIHJvd3MgZm9yIGl0ZW1zIHdoaWNoIHNwYW4gbXVsdGlwbGUgcm93cyAoc2VlICMxNjIsICMyMjQpXG4gIGRyYWdnYWJsZToge1xuICAgIGRlbGF5U3RhcnQ6IDAsIC8vIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc3RhcnQgb2YgZHJhZywgdXNlZnVsIGZvciB0b3VjaCBpbnRlcmFjdGlvblxuICAgIGVuYWJsZWQ6IGZhbHNlLCAvLyBlbmFibGUvZGlzYWJsZSBkcmFnZ2FibGUgaXRlbXNcbiAgICBpZ25vcmVDb250ZW50Q2xhc3M6ICdncmlkc3Rlci1pdGVtLWNvbnRlbnQnLCAvLyBkZWZhdWx0IGNvbnRlbnQgY2xhc3MgdG8gaWdub3JlIHRoZSBkcmFnIGV2ZW50IGZyb21cbiAgICBpZ25vcmVDb250ZW50OiBmYWxzZSwgLy8gaWYgdHJ1ZSBkcmFnIHdpbGwgc3RhcnQgb25seSBmcm9tIGVsZW1lbnRzIGZyb20gYGRyYWdIYW5kbGVDbGFzc2BcbiAgICBkcmFnSGFuZGxlQ2xhc3M6ICdkcmFnLWhhbmRsZXInLCAvLyBkcmFnIGV2ZW50IG9ubHkgZnJvbSB0aGlzIGNsYXNzLiBJZiBgaWdub3JlQ29udGVudGAgaXMgdHJ1ZS5cbiAgICBzdG9wOiB1bmRlZmluZWQsIC8vIGNhbGxiYWNrIHdoZW4gZHJhZ2dpbmcgYW4gaXRlbSBzdG9wcy4gIEFjY2VwdHMgUHJvbWlzZSByZXR1cm4gdG8gY2FuY2VsL2FwcHJvdmUgZHJhZy5cbiAgICBzdGFydDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB3aGVuIGRyYWdnaW5nIGFuIGl0ZW0gc3RhcnRzLlxuICAgIC8vIEFyZ3VtZW50czogaXRlbSwgZ3JpZHN0ZXJJdGVtLCBldmVudFxuICAgIGRyb3BPdmVySXRlbXM6IGZhbHNlLCAvLyBlbmFibGUgZHJvcCBpdGVtcyBvbiB0b3Agb3RoZXIgaXRlbVxuICAgIGRyb3BPdmVySXRlbXNDYWxsYmFjazogdW5kZWZpbmVkIC8vIGNhbGxiYWNrIG9uIGRyb3Agb3ZlciBhbm90aGVyIGl0ZW1cbiAgICAvLyBBcmd1bWVudHM6IHNvdXJjZSwgdGFyZ2V0LCBncmlkQ29tcG9uZW50XG4gIH0sXG4gIHJlc2l6YWJsZToge1xuICAgIGRlbGF5U3RhcnQ6IDAsIC8vIG1pbGxpc2Vjb25kcyB0byBkZWxheSB0aGUgc3RhcnQgb2YgcmVzaXplLCB1c2VmdWwgZm9yIHRvdWNoIGludGVyYWN0aW9uXG4gICAgZW5hYmxlZDogZmFsc2UsIC8vIGVuYWJsZS9kaXNhYmxlIHJlc2l6YWJsZSBpdGVtc1xuICAgIGhhbmRsZXM6IHtcbiAgICAgIHM6IHRydWUsXG4gICAgICBlOiB0cnVlLFxuICAgICAgbjogdHJ1ZSxcbiAgICAgIHc6IHRydWUsXG4gICAgICBzZTogdHJ1ZSxcbiAgICAgIG5lOiB0cnVlLFxuICAgICAgc3c6IHRydWUsXG4gICAgICBudzogdHJ1ZVxuICAgIH0sIC8vIHJlc2l6YWJsZSBlZGdlcyBvZiBhbiBpdGVtXG4gICAgc3RvcDogdW5kZWZpbmVkLCAvLyBjYWxsYmFjayB3aGVuIHJlc2l6aW5nIGFuIGl0ZW0gc3RvcHMuIEFjY2VwdHMgUHJvbWlzZSByZXR1cm4gdG8gY2FuY2VsL2FwcHJvdmUgcmVzaXplLlxuICAgIHN0YXJ0OiB1bmRlZmluZWQgLy8gY2FsbGJhY2sgd2hlbiByZXNpemluZyBhbiBpdGVtIHN0YXJ0cy5cbiAgICAvLyBBcmd1bWVudHM6IGl0ZW0sIGdyaWRzdGVySXRlbSwgZXZlbnRcbiAgfSxcbiAgc3dhcDogdHJ1ZSwgLy8gYWxsb3cgaXRlbXMgdG8gc3dpdGNoIHBvc2l0aW9uIGlmIGRyb3Agb24gdG9wIG9mIGFub3RoZXJcbiAgc3dhcFdoaWxlRHJhZ2dpbmc6IGZhbHNlLCAvLyBhbGxvdyBpdGVtcyB0byBzd2l0Y2ggcG9zaXRpb24gd2hpbGUgZHJhZ2dpbmdcbiAgcHVzaEl0ZW1zOiBmYWxzZSwgLy8gcHVzaCBpdGVtcyB3aGVuIHJlc2l6aW5nIGFuZCBkcmFnZ2luZ1xuICBkaXNhYmxlUHVzaE9uRHJhZzogZmFsc2UsIC8vIGRpc2FibGUgcHVzaCBvbiBkcmFnXG4gIGRpc2FibGVQdXNoT25SZXNpemU6IGZhbHNlLCAvLyBkaXNhYmxlIHB1c2ggb24gcmVzaXplXG4gIHB1c2hEaXJlY3Rpb25zOiB7IG5vcnRoOiB0cnVlLCBlYXN0OiB0cnVlLCBzb3V0aDogdHJ1ZSwgd2VzdDogdHJ1ZSB9LCAvLyBjb250cm9sIHRoZSBkaXJlY3Rpb25zIGl0ZW1zIGFyZSBwdXNoZWRcbiAgcHVzaFJlc2l6ZUl0ZW1zOiBmYWxzZSwgLy8gb24gcmVzaXplIG9mIGl0ZW0gd2lsbCBzaHJpbmsgYWRqYWNlbnQgaXRlbXNcbiAgZGlzcGxheUdyaWQ6IERpc3BsYXlHcmlkLk9uRHJhZ0FuZFJlc2l6ZSwgLy8gZGlzcGxheSBiYWNrZ3JvdW5kIGdyaWQgb2Ygcm93cyBhbmQgY29sdW1uc1xuICBkaXNhYmxlV2luZG93UmVzaXplOiBmYWxzZSwgLy8gZGlzYWJsZSB0aGUgd2luZG93IG9uIHJlc2l6ZSBsaXN0ZW5lci4gVGhpcyB3aWxsIHN0b3AgZ3JpZCB0byByZWNhbGN1bGF0ZSBvbiB3aW5kb3cgcmVzaXplLlxuICBkaXNhYmxlV2FybmluZ3M6IGZhbHNlLCAvLyBkaXNhYmxlIGNvbnNvbGUgbG9nIHdhcm5pbmdzIGFib3V0IG1pc3BsYWNlbWVudCBvZiBncmlkIGl0ZW1zXG4gIHNjcm9sbFRvTmV3SXRlbXM6IGZhbHNlLCAvLyBzY3JvbGwgdG8gbmV3IGl0ZW1zIHBsYWNlZCBpbiBhIHNjcm9sbGFibGUgdmlld1xuICBkaXNhYmxlU2Nyb2xsSG9yaXpvbnRhbDogZmFsc2UsIC8vIGRpc2FibGUgaG9yaXpvbnRhbCBzY3JvbGxpbmdcbiAgZGlzYWJsZVNjcm9sbFZlcnRpY2FsOiBmYWxzZSwgLy8gZGlzYWJsZSB2ZXJ0aWNhbCBzY3JvbGxpbmdcbiAgZW5hYmxlQm91bmRhcnlDb250cm9sOiBmYWxzZSwgLy8gZW5hYmxlIGJvdW5kYXJ5IGNvbnRyb2wgd2hpbGUgZHJhZ2dpbmcgaXRlbXNcbiAgZGlzYWJsZUF1dG9Qb3NpdGlvbk9uQ29uZmxpY3Q6IGZhbHNlLCAvLyBkaXNhYmxlIGF1dG8tcG9zaXRpb24gb2YgaXRlbXMgb24gY29uZmxpY3Qgc3RhdGUsXG4gIGRpclR5cGU6IERpclR5cGVzLkxUUiAvLyBwYWdlIGRpcmVjdGlvbiwgcnRsPXJpZ2h0IHRvIGxlZnQgbHRyPSBsZWZ0IHRvIHJpZ2h0LCBpZiB5b3UgdXNlIHJ0bCBsYW5ndWFnZSBzZXQgZGlyVHlwZSB0byBydGxcbn07XG4iXX0=